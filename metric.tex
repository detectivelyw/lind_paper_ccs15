\section{A Quantitative Metric and Our Key Hypothesis}
\label{sec.metric}
We devised a metric to quantitatively evaluate security aspects of the kernel. 
%It addresses a gap in that there is no standard method for properly evaluating 
%a system's security level. Thus, 
It enables a fair comparison of different security tools. 
We use our metric to investigate a critical question: which portions of the kernel are safe and 
contain few bugs? Our hypothesis is that \textbf{\textit{commonly used kernel paths}} contain few bugs. 
Our experimental results show that only $2.5\%$ of historical kernel bugs that we examined were 
found in commonly used kernel paths. Based on this measurement, we created a new design that 
places limited trust in commonly used kernel paths (in \S{4}). Using this new design, we built a prototype 
Lind, as an example of how to use our metric to design and implement secure systems (in \S{5}). 

\subsection{Rationale Behind Our Metric}
As discussed previously (\S{2}), %a key reason that existing techniques 
%fail to provide strong protection to the kernel is that there has yet to be a good way 
%or standard method to understand which portions of the kernel are safe 
%and which portions of the kernel are risky. 
we need to gain more knowledge about how the kernel should be exposed to user applications, 
and how to protect the interactions between the kernel space and 
the user space without drastic changes to the current kernel structure. 
Therefore, a metric to help understand this problem is desirable. 
%and could have huge practical impact. 
%
%In addition to having a standard method for measuring and evaluating the kernel, 
Additionally, such a metric would be a solid basis for comparison between different tools that try to 
provide secure environment for running programs. 
Currently, researchers and developers did not have a good way to evaluate the security features 
of their tools. 
%let along conduct comparison between different tools. However, to achieve the 
%goal of building and deploying secure systems, it would be very helpful if we could conduct fair and accurate 
%comparison between different tools. 
Our metric provides a quantitative way to 
facilitate such comparison. An example of comparison of evaluating security features among different tools is 
demonstrated in our evaluation (\S{6}).

\subsection{How Does the Metric Work?}
To evaluate security aspects of the kernel using our metric, there are two key steps. First, 
\textbf{\textit{the kernel trace}} of which lines of code in the kernel get executed is captured. 
Second, this kernel trace is checked against the historical kernel bugs to see if it contains kernel vulnerabilities. 

The first step is to capture the lines of kernel code get executed. 
The OS kernel code is organized under different kernel paths and directories. 
Whenever an application tries to access system resources, such as I/O, memory, and CPU, the kernel code 
under corresponding paths is executed. Therefore, the kernel code execution 
%can be viewed as the fundamental activities of the kernel, and it 
reflects the basic behavior of the kernel. \yanyan{behavior of kernel or application?}
Thus, %it makes sense to measure and analyze which lines of code get executed in the kernel. 
our metric %adopts this fundamental approach. It 
first captures which lines of code in the kernel get executed \yanyan{explain what a task program is?}
when running a certain task program, which we call a \textit{kernel trace}. The kernel trace closely
relates to the set of task programs that generated the trace. Therefore, conducting comparison between 
different tools and environments \yanyan{"tools and environments" is confusing. Do you mean 
applications? security tools?}
becomes possible by using the kernel traces. To capture the kernel trace, 
we use Gcov~\cite{gcov}, a component of the Linux kernel.
\yanyan{Is it part of Linux kernel? It is "a standard utility with the GNU Compiler Collection (GCC) suite"
according to wikipedia http://en.wikipedia.org/wiki/Gcov}

The second step is to evaluate security aspects of the kernel trace that we captured. Using the historical kernel vulnerability 
reports, we collect a list of severe kernel bugs. \yanyan{mention the source of bugs?}
For each of the bugs, we identify the lines of code 
in the kernel that would trigger the bug. \cappos{Need to make it clearer how
we do this. } We determine that the lines of code in the kernel are \textit{risky} if they 
may trigger certain kernel vulnerabilities, and those lines of code that cannot trigger kernel vulnerabilities are 
considered to be \textit{safe}. This provides us knowledge about the safety of the kernel portions.
%portions of the kernel are risky. 

\subsection{Key Hypothesis: Commonly Used Kernel Paths Contain Few Bugs}
%Now, to address the problem that motivated our metric from the very beginning, which portions of the kernel 
%are safe and which portions of the kernel are risky. We can use our metric to answer this question. To be more
%specific, 
In this section, we use our metric to get an idea of which lines of code in the kernel contain few bugs, and empirically label 
them as \textit{safe lines}. The safe lines of code would then compose the safe portions of the kernel, which can 
be trusted to build a secure trusted computing base for secure systems (\S{4}). 

Our hypothesis is that commonly used kernel paths are likely to be safe and contain few bugs. 
Here, ``commonly used kernel paths'' refers to the kernel paths executed by running popular 
applications, such as Web browsers, file editors, etc. 
The logic behind our hypothesis is that commonly used kernel paths are used
frequently and therefore bugs and vulnerabilities would have most likely
been caught by developers.  In addition, commonly used kernel paths usually 
include kernel functions that are used in a normal way rather than special 
corner cases. This means that the chances 
to harbor kernel bugs in those commonly used kernel paths are slim. 

\cappos{I feel it is a bit too much future tense here.  We did verify it.
It is fine to say we have a hypothesis, and that we provide some initial
results to confirm it.}
If our hypothesis can be verified, then it would become a critical guideline to create new designs for secure systems 
(shown in \S{4}). 
But before going too far into the new designs, let us first verify that our hypothesis indeed holds, that 
commonly used kernel paths are likely to contain few bugs and be safe. 
\yanyan{I feel this paragraph can be cut.}

\subsection{Verification of the Key Hypothesis}
So to verify our hypothesis that commonly used kernel paths contain few bugs, we 
first needed to obtain the commonly used kernel paths. 
We generated the commonly used kernel paths by using and combining two approaches, 
system call fuzzing and running popular user applications.  \cappos{I'm
confused about how fuzzing fits in here.}

User space applications interact with the kernel space essentially through the system call API. 
%So all those system calls are at the bottom level, while the applications sit at the top level. 
It makes sense then to obtain the kernel trace from both of those two different levels. 
We used two different approaches to obtain the kernel trace of commonly used kernel paths. 
Experiments of both approaches were conducted using the native Linux environment.

\textbf{1) the bottom-up approach: system call fuzzing.}
Our system call fuzzing runs system calls exhaustively with all possible 
arguments and options. We conducted system call fuzzing over more than 300 available system calls, 
\yanyan{such as call xyz.}which gave us a thorough kernel trace. 

\textbf{2) the top-down approach: running popular user applications.} 
We ran applications that are commonly used by many users on a daily basis, such as a Web browser, 
file editor, and so on.  

\begin{table}%[ht]
\centering
\scriptsize
\begin{tabular}{|l|c|}
  \hline
  \textbf{Approach} & \textbf{Kernel Coverage (percentage)} \\
  \hline \hline
  System Call Fuzzing & 23\% \\
  \hline
  User Applications & 19\% \\
  \hline
\end{tabular}
\caption {Kernel Coverage}
\label{table:kernel_coverage}
\end{table}

\begin{figure}%[h]
\centering
\includegraphics[width=1.0\columnwidth]{diagram/lind_ccs15_diagram_01.pdf}
\caption{Kernel Trace Comparison: Two Approaches\yanyan{may put \% numbers beside two bars, 
also remove the caption in the figure.}}
\label{fig:two_approaches_trace}
\end{figure}

\begin{figure}%[h]
\centering
\includegraphics[width=1.0\columnwidth]{diagram/lind_ccs15_diagram_02.pdf}
\caption{Kernel Trace in Key Paths}
\label{fig:key_paths_trace}
\end{figure}

\begin{table}[!ht]
\scriptsize
\begin{tabular}{|l|l|}
\hline
%\multicolumn{2}{|c|}{\bf Linux Kernel Bugs Examined} \\\hline
\textbf{Vulnerability}    &  \textbf{Specific Type} \\\hline

 CVE-2014-9529 \cite{CVE:20149529} & concurrency, race condition \\
 CVE-2014-3631 \cite{CVE:20143631} & NULL pointer dereference \\
 CVE-2012-6657 \cite{CVE:20126657} & network socket variable mischeck \\
 CVE-2014-5207 \cite{CVE:20145207} & privilege escalation \\
 CVE-2014-5206 \cite{CVE:20145206} & privilege escalation \\
 CVE-2014-3153 \cite{CVE:20143153} & privilege escalation \\
 CVE-2014-2851 \cite{CVE:20142851} & privilege escalation \\
 CVE-2014-2706 \cite{CVE:20142706} & race condition, DoS \\
 CVE-2014-0100 \cite{CVE:20140100} & race condition, DoS \\
 CVE-2014-0049 \cite{CVE:20140049} & buffer overflow \\
 CVE-2012-6638 \cite{CVE:20126638} & DoS \\
 CVE-2014-0038 \cite{CVE:20140038} & privilege escalation \\
 CVE-2013-6368 \cite{CVE:20136368} & privilege escalation  \\
 CVE-2013-4587 \cite{CVE:20134587} & index error, privilege escalation \\
 CVE-2013-4563 \cite{CVE:20134563} & size/boundary check, DoS \\
 CVE-2013-4348 \cite{CVE:20134348} & value validation error \\
 CVE-2013-4300 \cite{CVE:20134300} & privilege escalation  \\
 CVE-2013-1943 \cite{CVE:20131943} & privilege escalation \\
 CVE-2013-2094 \cite{CVE:20132094} & privilege escalation  \\
 CVE-2013-3301 \cite{CVE:20133301} & NULL pointer dereference, DoS \\
 CVE-2013-1858 \cite{CVE:20131858} & privilege escalation \\
 CVE-2013-1797 \cite{CVE:20131797} & use-after-free \\
 CVE-2013-1763 \cite{CVE:20131763} & privilege escalation, index error \\
 CVE-2013-0310 \cite{CVE:20130310} & NULL pointer dereference \\
 CVE-2012-2136 \cite{CVE:20122136} & heap-based buffer overflow \\
 CVE-2012-2100 \cite{CVE:20122100} & lack of sanity check \\
 CVE-2012-0028 \cite{CVE:20120028} & privilege escalation \\
 CVE-2011-2517 \cite{CVE:20112517} & privilege escalation, buffer overflow \\
 CVE-2012-2123 \cite{CVE:20122123} & privilege escalation \\
 CVE-2012-1146 \cite{CVE:20121146} & NULL pointer dereference \\
 CVE-2012-0207 \cite{CVE:20120207} & divide-by-zero error and panic \\
 CVE-2011-2525 \cite{CVE:20112525} & NULL pointer dereference \\
 CVE-2011-1076 \cite{CVE:20111076} & NULL pointer dereference \\
 CVE-2011-2184 \cite{CVE:20112184} & NULL pointer dereference, none initialization\\
 CVE-2010-2478 \cite{CVE:20102478} & integer overflow \\
 CVE-2010-2960 \cite{CVE:20102960} & NULL pointer dereference  \\
 CVE-2010-2492 \cite{CVE:20102492} & privilege escalation, buffer overflow \\
 CVE-2010-2240 \cite{CVE:20102240} & stack overflow \\
 CVE-2010-1188 \cite{CVE:20101188} & use-after-free \\
 CVE-2010-0437 \cite{CVE:20100437} & NULL pointer dereference \\
\hline
\end{tabular}
\caption {Linux Kernel Bugs Examined}
\label{table:kernel_bugs}
\end{table}

\begin{table}[!ht]
\scriptsize
\begin{tabular}{|l|c|c|}\hline
%\multicolumn{3}{c}{Vulnerabilities in Commonly Used Kernel Paths} \\\hline
\multirow{2}{*}{\textbf{Vulnerability}} & \multicolumn{2}{c|}{\bf Commonly Used Kernel Paths} \\
\cline{2-3}
&  \textbf{System Call Fuzzing} &  \textbf{User Application} \\ \hline

 CVE-2014-9529 \cite{CVE:20149529} & \ding{55} & \ding{55} \\
 CVE-2014-3631 \cite{CVE:20143631} & \ding{55} & \ding{55} \\
 CVE-2012-6657 \cite{CVE:20126657} & \ding{55} & \ding{55} \\
 CVE-2014-5207 \cite{CVE:20145207} & \ding{55} & \ding{55} \\
 CVE-2014-5206 \cite{CVE:20145206} & \ding{55} & \ding{55} \\
 CVE-2014-3153 \cite{CVE:20143153} & \ding{55} & \ding{55} \\
 CVE-2014-2851 \cite{CVE:20142851} & \ding{55} & \ding{55} \\
 CVE-2014-2706 \cite{CVE:20142706} & \ding{55} & \ding{55} \\
 CVE-2014-0100 \cite{CVE:20140100} & \ding{55} & \ding{55} \\
 CVE-2014-0049 \cite{CVE:20140049} & \ding{55} & \ding{55} \\
 CVE-2012-6638 \cite{CVE:20126638} & \ding{55} & \ding{55} \\
 CVE-2014-0038 \cite{CVE:20140038} & \ding{55} & \ding{55} \\
 CVE-2013-6368 \cite{CVE:20136368} & \ding{55} & \ding{55} \\
 CVE-2013-4587 \cite{CVE:20134587} & \ding{55} & \ding{55} \\
 CVE-2013-4563 \cite{CVE:20134563} & \ding{55} & \ding{55} \\
 CVE-2013-4348 \cite{CVE:20134348} & \ding{55} & \ding{55} \\
 CVE-2013-4300 \cite{CVE:20134300} & \ding{55} & \ding{55} \\
 CVE-2013-1943 \cite{CVE:20131943} & \ding{55} & \ding{55} \\
 CVE-2013-2094 \cite{CVE:20132094} & \ding{55} & \ding{55} \\
 CVE-2013-3301 \cite{CVE:20133301} & \ding{55} & \ding{55} \\
 CVE-2013-1858 \cite{CVE:20131858} & \ding{55} & \ding{55} \\
 CVE-2013-1797 \cite{CVE:20131797} & \ding{55} & \ding{55} \\
 CVE-2013-1763 \cite{CVE:20131763} & \ding{55} & \ding{55} \\
 CVE-2013-0310 \cite{CVE:20130310} & \ding{55} & \ding{55} \\
 CVE-2012-2136 \cite{CVE:20122136} & \ding{55} & \ding{55} \\
 CVE-2012-2100 \cite{CVE:20122100} & \ding{55} & \ding{55} \\
 CVE-2012-0028 \cite{CVE:20120028} & \ding{55} & \ding{55} \\
 CVE-2011-2517 \cite{CVE:20112517} & \ding{55} & \ding{55} \\
 CVE-2012-2123 \cite{CVE:20122123} & \ding{55} & \ding{55} \\
 CVE-2012-1146 \cite{CVE:20121146} & \ding{55} & \ding{55} \\
 CVE-2012-0207 \cite{CVE:20120207} & \ding{55} & \ding{55} \\
 CVE-2011-2525 \cite{CVE:20112525} & \ding{55} & \ding{55} \\
 CVE-2011-1076 \cite{CVE:20111076} & \ding{55} & \ding{55} \\
 CVE-2011-2184 \cite{CVE:20112184} & \ding{55} & \ding{55} \\
 CVE-2010-2478 \cite{CVE:20102478} & \ding{55} & \ding{55} \\
 CVE-2010-2960 \cite{CVE:20102960} & \ding{55} & \ding{55} \\
 CVE-2010-2492 \cite{CVE:20102492} & \ding{55} & \ding{55} \\
 CVE-2010-2240 \cite{CVE:20102240} & {\color{red}\ding{51}} & {\color{red}\ding{51}}\\
 CVE-2010-1188 \cite{CVE:20101188} & \ding{55} & \ding{55} \\
 CVE-2010-0437 \cite{CVE:20100437} & \ding{55} & \ding{55} \\ \hline
\end{tabular}
\caption {Vulnerabilities in Commonly Used Kernel Paths 
({\color{red}\ding{51}}: vulnerability in paths; \ding{55}: vulnerability not in paths)
\yanyan{Table~\ref{table:kernel_bugs} and \ref{table:vulnerabilities_commonly_used_kernel_paths} 
can be merged into one.}}
\label{table:vulnerabilities_commonly_used_kernel_paths}
\end{table}

Using these two approaches, we obtained the trace of commonly used kernel paths.
The kernel trace coverage of the two approaches are as shown in Table~\ref{table:kernel_coverage}. 
A further breakdown of the composition of the kernel trace is illustrated in Figure~\ref{fig:two_approaches_trace} and Figure~\ref{fig:key_paths_trace}.

The results from Table~\ref{table:kernel_coverage} show that the size of commonly used kernel paths is not very large, only about $20\%$ 
of the entire kernel code base. This shows that commonly used kernel paths are likely to contain 
few bugs, since the coverage of the commonly used kernel paths is small and leaves little space for vulnerabilities to exist. 
\yanyan{The small portion does not directly relate to contain few bugs.}

The results from Figure~\ref{fig:two_approaches_trace} and Figure~\ref{fig:key_paths_trace} show that for the two different approaches we used, most of the kernel trace was shared 
and under common paths. 
(Shown by the ``OverlappedPaths'' in Figure~\ref{fig:two_approaches_trace} and ``OverlappedLines'' in Figure~\ref{fig:key_paths_trace}.) \yanyan{may quote from the figs what \% are common.}
This shows that the kernel trace we generated was indeed commonly used, 
and our method to obtain commonly used kernel paths is reasonable. 

We then checked if those commonly used kernel paths contain few kernel bugs.
We examined a list of 40 severe Linux kernel bugs from the last five years (shown in Table~\ref{table:kernel_bugs}). 
We used those 40 kernel bugs to check if there are vulnerabilities within the trace of commonly used kernel paths.
The results of our experiment are shown in Table~\ref{table:vulnerabilities_commonly_used_kernel_paths}.  
\cappos{I'm confused.  Does this mean that almost all bugs couldn't be
triggered with the fuzzing tools?  If so, then the tools themselves seem
like they are terrible or else we are doing something wrong.  Is there a
better way to get code coverage / test coverage in the kernel?  Do they
have tests we can use for this?}

From the results, we can see that commonly used kernel paths contain only $2.5\%$ of the bugs we examined 
from the last five years.  
Our results imply that commonly used kernel paths
contain few bugs and are safe. \cappos{But does it?  If fuzzing only has
2.5\% available also, then why is this true?}
Our hypothesis and finding provide insights and guidelines for new designs of secure systems. We discuss details of 
a new design in the next section. 
