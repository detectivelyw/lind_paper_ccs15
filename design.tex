\section{A New Design for Building Secure Systems}
\label{sec.design}

\cappos{My thought: Section 2 argued we need to execute kernel code, including 
some `risky' functionality to make programs work.  Section 3 argued that `risky'
functionality is where vulnerabilities are likely to be.  Here we show how
to have a design that allows `risky' functionality to execute without 
causing a security problem.  Key idea: build a sandbox from safe functionality
and reimplement risky functionality inside of it.  We say all of this, but
some of it requires a careful read.}

%\cappos{It is good to make the threat model explicit, but I'm not sure here
%is the place to do it.  We've already been talking about zero-day kernel
%vulnerabilities.  It may make sense to locate the threat model earlier on.
%(Perhaps around section 2.)}

Our goal is to build a secure system that can mitigate the problem of kernel exploitation effectively. 
%As we have discussed in Section~\ref{sec.motivation}, one key reason that many previous work 
%failed to prevent kernel exploitation effectively is that there was not enough knowledge about 
%which portions of the kernel can be safely exposed to the user applications. 
%And there was no standard method to acquire this knowledge. 
The metric introduced in \S{\ref{sec.metric}} serves the purpose of having a standard method to 
obtain a better understanding of the kernel. % and to know which portions of the kernel can be safely exposed. 
Our findings in \S{\ref{sec.metric}} suggest that commonly used kernel paths contain fewer bugs.
In this section, we use this important result to guide our new design for building secure systems. 
Our goal is to allow applications to execute risky functionalities without triggering security bugs.

\subsection{Architecture Design}
To build a secure system, our design needs to effectively construct a safe environment in which user programs 
can run without triggering kernel bugs and break the whole system. 
\yanyan{Why does "user programs 
can run without worrying about triggering kernel bugs" result in a "secure system placed in the user space"?}
\yiwen{Because there are only two places to put our system: the kernel space and the user space. Putting the system 
in the kernel space would make the whole system become the trusted computing base, which will make it more vulnerable. 
So the natural solution is to put the system in the user space.}
To achieve this security goal, 
our secure system should be placed in the user space, and exist as a key layer between the user applications 
and the underlying OS kernel. To design a secure system, the following three 
questions need to be answered. 
%First of all, how should our system access the kernel? Secondly, what interface 
%should our system provide to the user programs? Finally, how to implement the inside of our system to make it work?

The first key question is how should our system access the kernel. Since now we know 
that commonly used kernel paths contain few bugs, it would be desirable to design a system that only access the 
commonly used kernel paths. Through our findings in \S{\ref{sec.metric}}, we can see that commonly used kernel paths have relatively 
small size. This indicates that it is possible to design a system with a very small 
trusted computing base. Thus, our design should only access fundamental system 
calls within commonly used kernel paths. A sandbox that provides a 
set of safe system calls would satisfy this requirement.
%\yanyan{the next sentence seems to repeat the previous sentences.}
%This gives our design a very small trusted computing base that places only very limited trust in the kernel code. Therefore, 
%As a result, our design barely has the chance to trigger kernel bugs and cause serious security problems. 

The second question is what interface should our system provide to user programs. 
Essentially, this represents the tradeoff between 
security and functionality. Our goal is to provide strong protection to our system, therefore, security is prioritized. We are willing 
to sacrifice certain functionality if better security can be achieved. \yanyan{I can't understand the relation between functionality vs. security and POSIX API.} 
\yiwen{better functionality support requires more access to the kernel and use of more risky system calls, therefore will result in less security. restricted POSIX API is the 
design decision we made, which puts security as the priority but also provides enough functionality.} 
Thus, our design provides a POSIX API to user programs with 
support of fundamental functions. In fact, a restricted POSIX API is good enough to support many popular applications, 
and even some very complex legacy applications. \yanyan{Use citations to back up?}

Finally, how to implement our system? 
To provide a restricted POSIX API that is sufficient to user programs, while accessing the kernel only in commonly used path requires our system to 
reconstruct and reimplement many functions in our system. Since the reimplementation is difficult and may contain bugs 
and raise security concerns, we require that the reimplementation done in a sandbox. In a contained 
environment, the reimplementation can construct the POSIX API effectively, without breaking other parts of the system.  

\subsection{Summary}
We have shown that using our finding that commonly used kernel paths contain few bugs as a key principle, a new design was created 
for building secure systems. Our design accesses only commonly used kernel paths, placing very limited trust within the kernel code. 
To provide sufficient functionality to user programs, our design safely reimplements fundamental functions inside a sandbox. Thus, many 
popular user applications and legacy programs can be supported by the POSIX API our system provides, while security will not be violated 
with the isolation provided by the sandbox. 

The design we described here does not rely on any specific technique or tool. To implement our design, it is possible to choose different techniques 
that suit well with specific needs or requirements. In the next section, we describe one implementation of our design. 
